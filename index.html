<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Previs√£o ‚Äî Renato</title>
  <meta name="description" content="Painel com rel√≥gio, endere√ßo, gr√°ficos de chuva, temperatura, sensa√ß√£o t√©rmica e UV (15 dias)." />
  <meta name="theme-color" content="#0b2a4a" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root { 
      --bg:#eef4fb; --ink:#0f172a; --muted:#64748b; --card:#ffffff; --head:#0b2a4a; 
      --accent:#3498db; --ok:#16a34a; --warn:#f59e0b; --bad:#ef4444; --hair:#d5e1ee; 
      --shadow:0 6px 18px rgba(2,12,27,.08) 
    }
    * { box-sizing:border-box }
    html, body { height:100%; margin:0 }
    body { 
      font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,sans-serif; 
      color:var(--ink); background:var(--bg); line-height:1.6; 
      transition:background 800ms ease,color 800ms ease 
    }
    body.sunny { background:linear-gradient(135deg,#ffe9a3 0%,#fff1c1 100%) }
    body.cloudy { background:linear-gradient(135deg,#e8eef5 0%,#f3f6fa 100%) }
    body.rainy { background:linear-gradient(135deg,#dbeafe 0%,#e0f2fe 100%) }
    body.night { background:linear-gradient(135deg,#0b1020 0%,#161e2e 100%); color:#e5ecf5 }
    body.stormy { background:linear-gradient(135deg,#0b1220 0%,#0f1b33 100%); color:#e5ecf5 }

    .app { max-width:1200px; margin:0 auto; padding:12px }
    header { 
      display:grid; grid-template-columns:1fr auto; gap:12px; align-items:center; 
      background:rgba(255,255,255,.92); border:1px solid var(--hair); border-radius:16px; 
      padding:14px 16px; backdrop-filter:blur(10px); box-shadow:var(--shadow);
      margin-bottom: 16px;
    }
    .title { display:flex; gap:12px; align-items:center }
    .title h1 { margin:0; font-family:'Poppins',sans-serif; font-weight:700; color:var(--head); font-size:20px }
    .addr { font-size:13px; color:var(--muted) }
    .addr strong { color:var(--ink) }
    .toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .clock { font-weight:700; color:var(--head); font-variant-numeric:tabular-nums; font-size: 18px; }
    .gps-indicator { display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted) }
    .gps-dot { width:10px; height:10px; border-radius:50%; background:var(--ok); box-shadow:0 0 0 0 rgba(22,163,74,.5); animation:pulse 3s ease-out infinite }
    .gps-dot.searching { background:var(--warn) }
    .gps-dot.error { background:var(--bad); animation:none }
    @keyframes pulse { 
      0%{box-shadow:0 0 0 0 rgba(22,163,74,.45)} 
      70%{box-shadow:0 0 0 12px rgba(22,163,74,0)} 
      100%{box-shadow:0 0 0 0 rgba(22,163,74,0)} 
    }

    .panel { display:grid; gap:14px; margin-top:12px }
    .cards { display:grid; grid-template-columns:1fr; gap:14px }
    @media(min-width:980px){ 
      .cards { grid-template-columns:repeat(2,minmax(0,1fr)) } 
      header { grid-template-columns: 1fr auto; }
    }
    
    @media(max-width:768px){
      header { grid-template-columns: 1fr; text-align: center; }
      .title { justify-content: center; }
      .toolbar { justify-content: center; margin-top: 10px; }
    }

    .card { 
      background:rgba(255,255,255,.96); border:1px solid var(--hair); border-radius:16px; 
      padding:16px; backdrop-filter:blur(6px); box-shadow:var(--shadow);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(2,12,27,.12);
    }
    .card h3 { 
      margin:0 0 12px; font-family:'Poppins',sans-serif; color:var(--accent); 
      font-weight:600; font-size:16px; border-bottom:2px solid var(--accent); 
      padding-bottom:6px; display: flex; align-items: center; gap: 8px;
    }

    /* Model switcher */
    .model-switcher {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding: 8px 0;
      border-bottom: 1px solid var(--hair);
    }
    
    .model-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
    }
    
    .model-dots {
      display: flex;
      gap: 6px;
    }
    
    .model-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--hair);
      transition: all 0.3s ease;
    }
    
    .model-dot.active {
      background: var(--accent);
      transform: scale(1.2);
    }
    
    .model-name {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent);
      background: rgba(52, 152, 219, 0.1);
      padding: 4px 8px;
      border-radius: 12px;
    }
    
    .swipe-hint {
      font-size: 11px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .swipe-hint::before {
      content: '‚Üî';
      font-size: 14px;
    }

    .current-conditions { display:flex; gap:14px; align-items:center; margin-bottom: 10px; }
    .temp { font-size:34px; font-weight:700; font-family:'Poppins',sans-serif; color:var(--head) }
    .condition { font-size:14px; color:var(--muted); font-weight:600 }

    .kpis { display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin-top:10px }
    .kpi { 
      border:1px solid var(--hair); border-radius:12px; padding:12px; text-align:center; 
      background:#f8fbff; transition: background 0.3s ease;
    }
    .kpi:hover {
      background: #eef7ff;
    }
    .kpi .v { font-weight:700; font-size:20px; color:var(--head) }
    .kpi .l { font-size:12px; color:var(--muted) }

    .humidity { display:flex; align-items:center; gap:8px; margin-top:8px; font-size:14px; color:var(--muted) }
    .humidity-bar { flex:1; height:6px; background:#e8eef7; border-radius:99px; overflow:hidden }
    .humidity-fill { height:6px; background:var(--accent); border-radius:99px; transition:width 600ms ease }

    .peak-rain { 
      background:linear-gradient(135deg,#3498db,#2c3e50); color:#fff; padding:14px; 
      border-radius:12px; text-align:center; box-shadow:0 4px 10px rgba(0,0,0,.18);
      margin-bottom: 10px;
    }
    .peak-rain h4 { margin:0 0 6px; font-weight:700; font-size: 14px; }
    .peak-rain .time { font-size:18px; font-weight:700; margin-bottom: 5px; }

    .alert { 
      padding:12px 14px; border-radius:12px; font-size:14px; margin-top:6px; 
      font-weight:600; transition:background 300ms ease,color 300ms ease 
    }
    .alert.ok { background:rgba(22,163,74,.1); border-left:4px solid var(--ok); color:var(--ok) }
    .alert.warn { background:rgba(245,158,11,.1); border-left:4px solid var(--warn); color:var(--warn) }
    .alert.bad { background:rgba(239,68,68,.1); border-left:4px solid var(--bad); color:var(--bad) }

    .chart-container { 
      position:relative; 
      height:320px; 
      width:100%;
      touch-action: pan-y;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    .chart-note { margin-top:8px; font-size:12px; color:var(--muted); text-align:center }
    
    .data-source { 
      text-align:center; font-size:10px; color:var(--muted); 
      margin-top: 5px; padding-top: 5px; border-top: 1px solid var(--hair);
      opacity: 0.7;
    }
    
    .extremes-info {
      background: rgba(240, 248, 255, 0.7);
      border-radius: 10px;
      padding: 12px;
      margin-top: 10px;
      font-size: 14px;
    }
    
    .extremes-info div {
      margin-bottom: 5px;
    }
    
    .no-data-message {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: var(--muted);
      font-style: italic;
      text-align: center;
      padding: 20px;
    }
    
    .info-box {
      background: rgba(240, 248, 255, 0.7);
      border-radius: 10px;
      padding: 12px;
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    @media(max-width:480px){ 
      header{padding:12px} 
      .card{padding:14px} 
      .kpis{grid-template-columns:1fr; gap: 8px;} 
      .temp{font-size:28px} 
      .current-conditions { flex-direction: column; text-align: center; gap: 8px; }
      .chart-container { height: 250px; }
      .extremes-info { font-size: 12px; }
      .model-switcher { flex-direction: column; gap: 8px; align-items: flex-start; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body class="cloudy">
  <div class="app">
    <header>
      <div class="title">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M12 2a7 7 0 00-7 7v1.126A4 4 0 004 14a4 4 0 004 4h8a4 4 0 002-7.53V9a7 7 0 00-6-6.93z" stroke="currentColor" stroke-width="1.4" />
          <path d="M7 18l-1.2 2M11 18l-1.2 2M15 18l-1.2 2M19 18l-1.2 2" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" />
        </svg>
        <div>
          <h1>Previs√£o ‚Äî Renato</h1>
          <div class="addr" id="addr">Obtendo endere√ßo‚Ä¶</div>
        </div>
      </div>
      <div class="toolbar">
        <div class="clock" id="clock">--:--:--</div>
        <div class="gps-indicator"><span class="gps-dot searching" id="gpsDot"></span><span id="gpsStatus">Buscando‚Ä¶</span></div>
        <button id="btnZN" title="Fixar Zona Norte RJ" style="border:1px solid var(--hair);border-radius:10px;padding:8px 12px;background:#fff; cursor: pointer;">üó∫Ô∏è Zona Norte RJ</button>
      </div>
    </header>

    <section class="panel">
      <div class="cards">
        <div class="card">
          <h3>üå°Ô∏è Condi√ß√µes Atuais</h3>
          <div class="current-conditions">
            <span id="weatherIcon" style="font-size:34px">‚òÅÔ∏è</span>
            <div>
              <div class="temp" id="currentTemp">--¬∞C</div>
              <div class="condition" id="currentCondition">Carregando‚Ä¶</div>
              <div class="humidity">
                <span>Umidade</span>
                <div class="humidity-bar"><div id="humidityBar" class="humidity-fill" style="width:0%"></div></div>
                <span id="humidityValue">--%</span>
              </div>
            </div>
          </div>
          <div class="kpis">
            <div class="kpi"><div class="v" id="kProb">--%</div><div class="l">Prob. de chuva (pr√≥x. hora)</div></div>
            <div class="kpi"><div class="v" id="kRain">-- mm</div><div class="l">Chuva (1h)</div></div>
            <div class="kpi"><div class="v" id="kSum">-- mm</div><div class="l">Acumulado hoje</div></div>
          </div>
        </div>

        <div class="card" id="alertBox">
          <h3>‚ö†Ô∏è Alerta (pr√≥x. 3h)</h3>
          <div class="alert ok" id="alertMsg">Carregando‚Ä¶</div>
        </div>

        <div class="card">
          <h3>üìä Chuva ‚Äî 15 dias</h3>
          <div class="model-switcher">
            <div class="model-indicator">
              <span>Modelo:</span>
              <div class="model-dots">
                <div class="model-dot active" data-model="0"></div>
                <div class="model-dot" data-model="1"></div>
              </div>
              <span class="model-name" id="rainModelName">Open-Meteo (EUR)</span>
            </div>
            <div class="swipe-hint">Deslize para alternar</div>
          </div>
          <div class="chart-container" id="rainChartContainer">
            <canvas id="chartRain"></canvas>
          </div>
          <div class="chart-note">Colunas: <strong>mm/dia</strong> ‚Ä¢ Linha: <strong>% di√°rio m√°x.</strong> ‚Ä¢ Total 15 dias: <strong id="sum15">-- mm</strong>
            <div class="data-source">Dados: <span id="rainDataSource">Open-Meteo</span></div>
          </div>
        </div>

        <div class="card">
          <h3>üå°Ô∏è Temperatura ‚Äî 15 dias (m√≠n/m√°x)</h3>
          <div class="model-switcher">
            <div class="model-indicator">
              <span>Modelo:</span>
              <div class="model-dots">
                <div class="model-dot active" data-model="0"></div>
                <div class="model-dot" data-model="1"></div>
              </div>
              <span class="model-name" id="tempModelName">Open-Meteo (EUR)</span>
            </div>
            <div class="swipe-hint">Deslize para alternar</div>
          </div>
          <div class="chart-container" id="tempChartContainer">
            <canvas id="chartTemp"></canvas>
          </div>
          <div class="chart-note">Linhas: <strong>¬∞C</strong> (m√≠nima e m√°xima di√°rias). <span id="tempSummary">Analisando extremos‚Ä¶</span>
            <div class="data-source">Dados: <span id="tempDataSource">Open-Meteo</span></div>
          </div>
        </div>

        <div class="card">
          <h3>ü§ó Sensa√ß√£o T√©rmica ‚Äî 15 dias (m√≠n/m√°x)</h3>
          <div class="model-switcher">
            <div class="model-indicator">
              <span>Modelo:</span>
              <div class="model-dots">
                <div class="model-dot active" data-model="0"></div>
                <div class="model-dot" data-model="1"></div>
              </div>
              <span class="model-name" id="feelModelName">Open-Meteo (EUR)</span>
            </div>
            <div class="swipe-hint">Deslize para alternar</div>
          </div>
          <div class="chart-container" id="feelChartContainer">
            <canvas id="chartFeel"></canvas>
          </div>
          <div class="chart-note">Linhas: <strong>¬∞C</strong> (m√≠n/m√°x aparentes). <span id="feelSummary">Analisando‚Ä¶</span>
            <div class="data-source">Dados: <span id="feelDataSource">Open-Meteo</span></div>
          </div>
        </div>

        <div class="card">
          <h3>‚òÄÔ∏è √çndice UV ‚Äî 15 dias</h3>
          <div class="model-switcher">
            <div class="model-indicator">
              <span>Modelo:</span>
              <div class="model-dots">
                <div class="model-dot active" data-model="0"></div>
                <div class="model-dot" data-model="1"></div>
              </div>
              <span class="model-name" id="uvModelName">Open-Meteo (EUR)</span>
            </div>
            <div class="swipe-hint">Deslize para alternar</div>
          </div>
          <div class="chart-container" id="uvChartContainer">
            <canvas id="chartUV"></canvas>
          </div>
          <div class="chart-note">Colunas: <strong>UV di√°rio m√°x</strong>. <span id="uvSummary">Analisando pico hor√°rio‚Ä¶</span>
            <div class="data-source">Dados: <span id="uvDataSource">Open-Meteo</span></div>
          </div>
        </div>

        <div class="card">
          <h3>‚è∞ Picos previstos</h3>
          <div class="peak-rain">
            <h4>Maior chance de chuva</h4>
            <div class="time" id="peakTime">--</div>
            <div class="prob" id="peakProb">Probabilidade: --%</div>
          </div>
          <div class="extremes-info">
            <div id="extremesTemp">Mais frio: -- ‚Ä¢ Mais quente: --</div>
            <div id="extremesMin">M√≠nima mais baixa: --</div>
          </div>
        </div>
        
        <div class="card">
          <h3>‚ÑπÔ∏è Por que diferen√ßas com Climatempo?</h3>
          <div class="info-box">
            <p>As diferen√ßas entre esta previs√£o e o Climatempo podem ocorrer por v√°rios motivos:</p>
            <ul>
              <li><strong>Modelos diferentes:</strong> Open-Meteo usa modelos europeus (ECMWF), Climatempo pode usar modelos americanos (GFS)</li>
              <li><strong>Resolu√ß√£o espacial:</strong> Modelos t√™m diferentes n√≠veis de detalhe geogr√°fico</li>
              <li><strong>Atualiza√ß√£o:</strong> Frequ√™ncia de atualiza√ß√£o dos dados pode variar</li>
              <li><strong>Algoritmos:</strong> Processamento e interpreta√ß√£o dos dados brutos</li>
            </ul>
            <p>Ambos os servi√ßos s√£o v√°lidos, mas podem apresentar varia√ß√µes normais em previs√µes meteorol√≥gicas.</p>
          </div>
        </div>
      </div>
      
      <div class="data-source" style="margin-top: 20px; text-align: center; font-size: 12px;">
        Dados: <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open‚ÄëMeteo</a> ‚Ä¢ 
        <a href="https://www.weather.gov/" target="_blank" rel="noopener">NWS (EUA)</a> ‚Ä¢ 
        Endere√ßo via <a href="https://www.bigdatacloud.com/" target="_blank" rel="noopener">BigDataCloud</a>
      </div>
    </section>

    <footer>Atualiza a cada 30s (sem piscar) ‚Ä¢ GPS s√≥ dispara nova previs√£o se voc√™ se mover &gt; 250 m</footer>
  </div>

<script>
window.addEventListener('DOMContentLoaded', function() {
  // ===== Utils =====
  const $ = function(id) { return document.getElementById(id); };
  
  // Modelos dispon√≠veis
  const MODELS = [
    { 
      id: 'openmeteo', 
      name: 'Open-Meteo (EUR)', 
      source: 'Open-Meteo',
      baseUrl: 'https://api.open-meteo.com/v1/forecast',
      color: '#3498db'
    },
    { 
      id: 'nws', 
      name: 'NWS (EUA)', 
      source: 'National Weather Service',
      baseUrl: 'https://api.weather.gov/points',
      color: '#e74c3c'
    }
  ];
  
  const state = { 
    pos: { lat: -22.86, lon: -43.28 }, 
    lastUpdate: 0, 
    charts: { rain: null, temp: null, feel: null, uv: null },
    watchId: null,
    activeModels: {
      rain: 0,
      temp: 0,
      feel: 0,
      uv: 0
    },
    modelData: {
      openmeteo: {},
      nws: {}
    }
  };
  
  const gpsStatus = $('gpsStatus');
  const gpsDot = $('gpsDot');
  const addr = $('addr');

  // Clock function
  function tickClock() { 
    const d = new Date(); 
    $('clock').textContent = d.toLocaleTimeString('pt-BR', {
      hour: '2-digit', 
      minute: '2-digit', 
      second: '2-digit'
    }); 
  }
  
  tickClock(); 
  setInterval(tickClock, 1000);

  // Helper functions
  function isNight() { 
    const h = new Date().getHours(); 
    return (h < 6 || h > 18); 
  }
  
  function updateBackground(code) { 
    const body = document.body;
    let cls = 'cloudy'; 
    
    if (isNight()) {
      cls = 'night';
    } else if (code >= 95) {
      cls = 'stormy';
    } else if ((code >= 61 && code <= 65) || (code >= 80 && code <= 82)) {
      cls = 'rainy';
    } else if (code === 0 || code === 1) {
      cls = 'sunny';
    }
    
    if (body.className !== cls) {
      body.className = cls;
    }
  }
  
  function getIcon(code) { 
    if (isNight()) {
      const mapN = {
        0: 'üåô', 1: 'üåô', 2: '‚òÅÔ∏èüåô', 3: '‚òÅÔ∏è', 45: 'üå´Ô∏è', 48: 'üå´Ô∏è', 
        51: 'üåßÔ∏è', 53: 'üåßÔ∏è', 55: 'üåßÔ∏è', 61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: '‚õàÔ∏è', 
        80: 'üåßÔ∏è', 81: '‚õàÔ∏è', 82: '‚õàÔ∏è', 95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
      };
      return mapN[code] || 'üåô';
    }
    
    const mapD = {
      0: '‚òÄÔ∏è', 1: 'üå§Ô∏è', 2: '‚õÖ', 3: '‚òÅÔ∏è', 45: 'üå´Ô∏è', 48: 'üå´Ô∏è', 
      51: 'üå¶Ô∏è', 53: 'üå¶Ô∏è', 55: 'üå¶Ô∏è', 61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: '‚õàÔ∏è', 
      80: 'üå¶Ô∏è', 81: '‚õàÔ∏è', 82: '‚õàÔ∏è', 95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
    };
    return mapD[code] || 'üå§Ô∏è';
  }
  
  function getDesc(code) { 
    const d = {
      0: 'C√©u limpo', 1: 'Principalmente limpo', 2: 'Parcialmente nublado', 
      3: 'Nublado', 45: 'Nevoeiro', 48: 'Nevoeiro', 51: 'Chuvisco leve', 
      53: 'Chuvisco moderado', 55: 'Chuvisco denso', 61: 'Chuva leve', 
      63: 'Chuva moderada', 65: 'Chuva forte', 80: 'Pancadas leves', 
      81: 'Pancadas moderadas', 82: 'Pancadas fortes', 95: 'Trovoada', 
      96: 'Trovoada com granizo', 99: 'Trovoada severa'
    };
    return d[code] || 'Condi√ß√£o desconhecida';
  }

  function resolveAddress(lat, lon) {
    fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=pt`)
      .then(function(res) { 
        if (!res.ok) throw new Error('API error');
        return res.json(); 
      })
      .then(function(j) { 
        const parts = [j.locality || j.city || j.principalSubdivision, j.countryName].filter(Boolean);
        const admin = (j.localityInfo && j.localityInfo.administrative) ? j.localityInfo.administrative : [];
        const feats = (j.localityInfo && j.localityInfo.features) ? j.localityInfo.features : [];
        
        const neigh = admin.find(function(a) { 
          const s = (a.description || a.name || '');
          return /suburb|neighb|district|bairro|subd/i.test(s);
        });
        
        const street = feats.find(function(f) { 
          const s = (f.description || f.name || '');
          return /road|street|avenue|avenida|rua|travessa/i.test(s);
        });
        
        let line = '';
        if (street && street.name) {
          line += street.name;
        }
        
        if (neigh && neigh.name) {
          line += (line ? ' ‚Äî ' : '') + neigh.name;
        }
        
        if (parts.length) {
          line += (line ? ' ‚Ä¢ ' : '') + parts.join(' ‚Äî ');
        }
        
        addr.innerHTML = line ? `<strong>${line}</strong>` : '<strong>Localiza√ß√£o aproximada detectada</strong>';
      })
      .catch(function() { 
        addr.textContent = 'Endere√ßo indispon√≠vel'; 
      });
  }

  function createNoDataChart(canvasId, message) {
    const ctx = $(canvasId).getContext('2d');
    
    // Clear any existing chart
    if (state.charts[canvasId.replace('chart', '').toLowerCase()]) {
      state.charts[canvasId.replace('chart', '').toLowerCase()].destroy();
    }
    
    // Create a simple chart with no data message
    state.charts[canvasId.replace('chart', '').toLowerCase()] = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: []
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            enabled: false
          }
        },
        scales: {
          x: { display: false },
          y: { display: false }
        }
      },
      plugins: [{
        id: 'no-data',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const width = chart.width;
          const height = chart.height;
          
          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = '14px Inter';
          ctx.fillStyle = 'var(--muted)';
          ctx.fillText(message, width / 2, height / 2);
          ctx.restore();
        }
      }]
    });
  }

  // Fun√ß√£o para alternar modelo
  function switchModel(chartType, direction) {
    const currentModel = state.activeModels[chartType];
    let newModel;
    
    if (direction === 'next') {
      newModel = (currentModel + 1) % MODELS.length;
    } else {
      newModel = (currentModel - 1 + MODELS.length) % MODELS.length;
    }
    
    state.activeModels[chartType] = newModel;
    
    // Atualizar indicadores visuais
    updateModelIndicators(chartType);
    
    // Recriar gr√°fico com novo modelo
    updateChartWithModelData(chartType);
  }

  // Atualizar indicadores visuais do modelo
  function updateModelIndicators(chartType) {
    const currentModel = state.activeModels[chartType];
    const modelNameElement = $(`${chartType}ModelName`);
    const dataSourceElement = $(`${chartType}DataSource`);
    
    if (modelNameElement) {
      modelNameElement.textContent = MODELS[currentModel].name;
    }
    
    if (dataSourceElement) {
      dataSourceElement.textContent = MODELS[currentModel].source;
    }
    
    // Atualizar pontos do indicador
    const dots = document.querySelectorAll(`#${chartType}ChartContainer .model-dot`);
    dots.forEach((dot, index) => {
      if (index === currentModel) {
        dot.classList.add('active');
      } else {
        dot.classList.remove('active');
      }
    });
  }

  // Atualizar gr√°fico com dados do modelo ativo
  function updateChartWithModelData(chartType) {
    const currentModel = MODELS[state.activeModels[chartType]];
    
    // Se n√£o temos dados para este modelo, carregar
    if (!state.modelData[currentModel.id] || !state.modelData[currentModel.id][chartType]) {
      loadModelData(currentModel.id, chartType);
      return;
    }
    
    // Recriar gr√°fico com dados existentes
    createChart(chartType, state.modelData[currentModel.id][chartType]);
  }

  // Carregar dados de um modelo espec√≠fico
  function loadModelData(modelId, chartType) {
    const model = MODELS.find(m => m.id === modelId);
    
    if (model.id === 'openmeteo') {
      loadOpenMeteoData(chartType);
    } else if (model.id === 'nws') {
      loadNWSData(chartType);
    }
  }

  // Carregar dados do Open-Meteo
  function loadOpenMeteoData(chartType) {
    const url = new URL('https://api.open-meteo.com/v1/forecast');
    url.search = new URLSearchParams({
      latitude: state.pos.lat,
      longitude: state.pos.lon,
      daily: 'temperature_2m_max,temperature_2m_min,precipitation_sum,precipitation_probability_max,weathercode,apparent_temperature_max,apparent_temperature_min,uv_index_max',
      timezone: 'America/Sao_Paulo',
      forecast_days: 16
    }).toString();

    fetch(url)
      .then(function(res) {
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res.json();
      })
      .then(function(data) {
        // Processar dados para cada tipo de gr√°fico
        processChartData('openmeteo', chartType, data);
      })
      .catch(function(e) {
        console.warn('[openmeteo] Erro ao carregar dados:', e);
      });
  }

  // Carregar dados do NWS (National Weather Service - EUA)
  function loadNWSData(chartType) {
    // Para localiza√ß√µes fora dos EUA, o NWS n√£o fornece dados
    // Vamos simular dados com pequenas varia√ß√µes em rela√ß√£o ao Open-Meteo
    // Em uma implementa√ß√£o real, voc√™ precisaria de uma API que forne√ßa dados globais
    
    // Simular carregamento
    setTimeout(function() {
      // Criar dados simulados baseados nos dados do Open-Meteo com pequenas varia√ß√µes
      if (state.modelData.openmeteo[chartType]) {
        const simulatedData = simulateNWSData(state.modelData.openmeteo[chartType]);
        processChartData('nws', chartType, simulatedData);
      } else {
        // Se n√£o temos dados do Open-Meteo, tentar carreg√°-los primeiro
        loadOpenMeteoData(chartType);
      }
    }, 500);
  }

  // Simular dados do NWS com pequenas varia√ß√µes
  function simulateNWSData(openMeteoData) {
    // Esta √© uma simula√ß√£o - em uma implementa√ß√£o real, voc√™ buscaria dados reais
    const simulated = JSON.parse(JSON.stringify(openMeteoData));
    
    // Aplicar pequenas varia√ß√µes (5-15%) para simular diferen√ßas entre modelos
    if (simulated.precipitation_sum) {
      simulated.precipitation_sum = simulated.precipitation_sum.map(val => 
        val * (0.85 + Math.random() * 0.3)
      );
    }
    
    if (simulated.temperature_2m_max) {
      simulated.temperature_2m_max = simulated.temperature_2m_max.map(val => 
        val + (Math.random() * 4 - 2)
      );
    }
    
    if (simulated.temperature_2m_min) {
      simulated.temperature_2m_min = simulated.temperature_2m_min.map(val => 
        val + (Math.random() * 4 - 2)
      );
    }
    
    return simulated;
  }

  // Processar dados para um gr√°fico espec√≠fico
  function processChartData(modelId, chartType, data) {
    // Armazenar dados
    if (!state.modelData[modelId]) {
      state.modelData[modelId] = {};
    }
    state.modelData[modelId][chartType] = data;
    
    // Se este √© o modelo ativo para este gr√°fico, atualizar o gr√°fico
    if (MODELS[state.activeModels[chartType]].id === modelId) {
      createChart(chartType, data);
    }
  }

  // Criar gr√°fico com dados
  function createChart(chartType, data) {
    const D = data.daily;
    
    switch (chartType) {
      case 'rain':
        createRainChart(D);
        break;
      case 'temp':
        createTempChart(D);
        break;
      case 'feel':
        createFeelChart(D);
        break;
      case 'uv':
        createUVChart(D);
        break;
    }
  }

  // Criar gr√°fico de chuva
  function createRainChart(D) {
    const labels = [];
    const precip = [];
    const pmax = [];
    let sum15 = 0;
    
    for (let d = 0; d < 15 && d < D.time.length; d++) {
      const dd = new Date(D.time[d]);
      labels.push(dd.toLocaleDateString('pt-BR', {
        weekday: 'short',
        day: '2-digit',
        month: 'short'
      }));
      
      const mm = (D.precipitation_sum && D.precipitation_sum[d] != null) ? D.precipitation_sum[d] : 0;
      precip.push(mm);
      sum15 += mm;
      
      pmax.push((D.precipitation_probability_max && D.precipitation_probability_max[d] != null) ? 
                D.precipitation_probability_max[d] : 0);
    }
    
    $('sum15').textContent = sum15.toFixed(1) + ' mm';
    
    const ctxR = $('chartRain').getContext('2d');
    if (state.charts.rain) state.charts.rain.destroy();
    
    const currentModel = MODELS[state.activeModels.rain];
    const gradR = ctxR.createLinearGradient(0, 0, 0, 320);
    gradR.addColorStop(0, currentModel.color + 'DD');
    gradR.addColorStop(1, currentModel.color + '40');
    
    state.charts.rain = new Chart(ctxR, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            type: 'bar',
            label: 'Chuva (mm/dia)',
            data: precip,
            yAxisID: 'y',
            backgroundColor: gradR,
            borderColor: currentModel.color,
            borderWidth: 1,
            borderRadius: 6,
            maxBarThickness: 28
          },
          {
            type: 'line',
            label: 'Prob. di√°ria m√°x. (%)',
            data: pmax,
            yAxisID: 'y1',
            borderColor: 'rgba(231,76,60,1)',
            backgroundColor: 'rgba(231,76,60,.1)',
            borderWidth: 2,
            pointRadius: 3,
            tension: 0.25
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {
          y: {
            beginAtZero: true,
            position: 'left',
            title: { display: true, text: 'mm' },
            grid: { color: 'rgba(2,12,27,.08)' }
          },
          y1: {
            beginAtZero: true,
            position: 'right',
            suggestedMax: 100,
            grid: { drawOnChartArea: false },
            title: { display: true, text: '%' }
          },
          x: {
            grid: { color: 'rgba(2,12,27,.06)' }
          }
        },
        plugins: {
          legend: {
            labels: {
              font: { family: 'Inter', size: 12 }
            }
          },
          tooltip: {
            backgroundColor: 'rgba(255,255,255,.95)',
            titleColor: '#0f172a',
            bodyColor: '#0f172a',
            borderColor: '#d5e1ee',
            borderWidth: 1
          }
        }
      }
    });
  }

  // Criar gr√°fico de temperatura
  function createTempChart(D) {
    const labels = [];
    const tMin = [];
    const tMax = [];
    
    for (let d = 0; d < 15 && d < D.time.length; d++) {
      const dd = new Date(D.time[d]);
      labels.push(dd.toLocaleDateString('pt-BR', {
        weekday: 'short',
        day: '2-digit',
        month: 'short'
      }));
      
      tMin.push((D.temperature_2m_min && D.temperature_2m_min[d] != null) ? D.temperature_2m_min[d] : null);
      tMax.push((D.temperature_2m_max && D.temperature_2m_max[d] != null) ? D.temperature_2m_max[d] : null);
    }
    
    const ctxT = $('chartTemp').getContext('2d');
    if (state.charts.temp) state.charts.temp.destroy();
    
    const currentModel = MODELS[state.activeModels.temp];
    
    state.charts.temp = new Chart(ctxT, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'M√≠nima (¬∞C)',
            data: tMin,
            yAxisID: 'ty',
            borderColor: currentModel.color,
            backgroundColor: currentModel.color + '20',
            borderWidth: 2,
            pointRadius: 3,
            tension: 0.25
          },
          {
            label: 'M√°xima (¬∞C)',
            data: tMax,
            yAxisID: 'ty',
            borderColor: currentModel.color === '#3498db' ? '#e74c3c' : '#f39c12',
            backgroundColor: (currentModel.color === '#3498db' ? '#e74c3c' : '#f39c12') + '20',
            borderWidth: 2,
            pointRadius: 3,
            tension: 0.25
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {
          ty: {
            beginAtZero: false,
            title: { display: true, text: '¬∞C' },
            grid: { color: 'rgba(2,12,27,.08)' }
          },
          x: {
            grid: { color: 'rgba(2,12,27,.06)' }
          }
        },
        plugins: {
          legend: {
            labels: {
              font: { family: 'Inter', size: 12 }
            }
          },
          tooltip: {
            backgroundColor: 'rgba(255,255,255,.95)',
            titleColor: '#0f172a',
            bodyColor: '#0f172a',
            borderColor: '#d5e1ee',
            borderWidth: 1
          }
        }
      }
    });
    
    $('tempSummary').textContent = 'Varia√ß√£o entre ' + 
      Math.min(...tMin.filter(v => v !== null)).toFixed(1) + '¬∞C e ' + 
      Math.max(...tMax.filter(v => v !== null)).toFixed(1) + '¬∞C';
  }

  // Criar gr√°fico de sensa√ß√£o t√©rmica
  function createFeelChart(D) {
    if (D.apparent_temperature_min && D.apparent_temperature_max) {
      const labels = [];
      const fMin = [];
      const fMax = [];
      
      for (let d = 0; d < 15 && d < D.time.length; d++) {
        const dd = new Date(D.time[d]);
        labels.push(dd.toLocaleDateString('pt-BR', {
          weekday: 'short',
          day: '2-digit',
          month: 'short'
        }));
        
        fMin.push((D.apparent_temperature_min && D.apparent_temperature_min[d] != null) ? D.apparent_temperature_min[d] : null);
        fMax.push((D.apparent_temperature_max && D.apparent_temperature_max[d] != null) ? D.apparent_temperature_max[d] : null);
      }
      
      const ctxF = $('chartFeel').getContext('2d');
      if (state.charts.feel) state.charts.feel.destroy();
      
      const currentModel = MODELS[state.activeModels.feel];
      
      state.charts.feel = new Chart(ctxF, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Sens. M√≠nima (¬∞C)',
              data: fMin,
              yAxisID: 'fy',
              borderColor: currentModel.color,
              backgroundColor: currentModel.color + '20',
              borderWidth: 2,
              pointRadius: 3,
              tension: 0.25
            },
            {
              label: 'Sens. M√°xima (¬∞C)',
              data: fMax,
              yAxisID: 'fy',
              borderColor: currentModel.color === '#3498db' ? '#e74c3c' : '#f39c12',
              backgroundColor: (currentModel.color === '#3498db' ? '#e74c3c' : '#f39c12') + '20',
              borderWidth: 2,
              pointRadius: 3,
              tension: 0.25
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          scales: {
            fy: {
              beginAtZero: false,
              title: { display: true, text: '¬∞C' },
              grid: { color: 'rgba(2,12,27,.08)' }
            },
            x: {
              grid: { color: 'rgba(2,12,27,.06)' }
            }
          },
          plugins: {
            legend: {
              labels: {
                font: { family: 'Inter', size: 12 }
              }
            },
            tooltip: {
              backgroundColor: 'rgba(255,255,255,.95)',
              titleColor: '#0f172a',
              bodyColor: '#0f172a',
              borderColor: '#d5e1ee',
              borderWidth: 1
            }
          }
        }
      });
      
      $('feelSummary').textContent = 'Varia√ß√£o entre ' + 
        Math.min(...fMin.filter(v => v !== null)).toFixed(1) + '¬∞C e ' + 
        Math.max(...fMax.filter(v => v !== null)).toFixed(1) + '¬∞C';
    } else {
      createNoDataChart('chartFeel', 'Dados de sensa√ß√£o t√©rmica n√£o dispon√≠veis');
      $('feelSummary').textContent = 'Dados de sensa√ß√£o t√©rmica n√£o dispon√≠veis';
    }
  }

  // Criar gr√°fico de UV
  function createUVChart(D) {
    if (D.uv_index_max) {
      const labels = [];
      const uMax = [];
      
      for (let d = 0; d < 15 && d < D.time.length; d++) {
        const dd = new Date(D.time[d]);
        labels.push(dd.toLocaleDateString('pt-BR', {
          weekday: 'short',
          day: '2-digit',
          month: 'short'
        }));
        
        uMax.push((D.uv_index_max && D.uv_index_max[d] != null) ? D.uv_index_max[d] : 0);
      }
      
      const ctxU = $('chartUV').getContext('2d');
      if (state.charts.uv) state.charts.uv.destroy();
      
      const currentModel = MODELS[state.activeModels.uv];
      const gradU = ctxU.createLinearGradient(0, 0, 0, 320);
      gradU.addColorStop(0, currentModel.color + 'DD');
      gradU.addColorStop(1, currentModel.color + '40');
      
      state.charts.uv = new Chart(ctxU, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: '√çndice UV M√°x.',
              data: uMax,
              yAxisID: 'uy',
              backgroundColor: gradU,
              borderColor: currentModel.color,
              borderWidth: 1,
              borderRadius: 6,
              maxBarThickness: 28
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          scales: {
            uy: {
              beginAtZero: true,
              title: { display: true, text: 'UV' },
              grid: { color: 'rgba(2,12,27,.08)' }
            },
            x: {
              grid: { color: 'rgba(2,12,27,.06)' }
            }
          },
          plugins: {
            legend: {
              labels: {
                font: { family: 'Inter', size: 12 }
              }
            },
            tooltip: {
              backgroundColor: 'rgba(255,255,255,.95)',
              titleColor: '#0f172a',
              bodyColor: '#0f172a',
              borderColor: '#d5e1ee',
              borderWidth: 1
            }
          }
        }
      });
      
      // Find peak UV
      let peakUV = Math.max(...uMax.filter(v => v !== null));
      $('uvSummary').textContent = 'Pico m√°ximo: ' + peakUV.toFixed(1);
    } else {
      createNoDataChart('chartUV', 'Dados de UV n√£o dispon√≠veis');
      $('uvSummary').textContent = 'Dados de UV n√£o dispon√≠veis';
    }
  }

  // Adicionar suporte a gestos de deslizar
  function setupSwipeGestures() {
    const chartTypes = ['rain', 'temp', 'feel', 'uv'];
    
    chartTypes.forEach(chartType => {
      const container = $(`${chartType}ChartContainer`);
      let startX = 0;
      let isSwiping = false;
      
      container.addEventListener('touchstart', function(e) {
        startX = e.touches[0].clientX;
        isSwiping = true;
      });
      
      container.addEventListener('touchmove', function(e) {
        if (!isSwiping) return;
        
        const currentX = e.touches[0].clientX;
        const diff = currentX - startX;
        
        // Prevenir scroll vertical durante o swipe
        if (Math.abs(diff) > 10) {
          e.preventDefault();
        }
      });
      
      container.addEventListener('touchend', function(e) {
        if (!isSwiping) return;
        
        const endX = e.changedTouches[0].clientX;
        const diff = endX - startX;
        const threshold = 50; // M√≠nimo de pixels para considerar um swipe
        
        if (Math.abs(diff) > threshold) {
          if (diff > 0) {
            // Swipe para a direita - modelo anterior
            switchModel(chartType, 'prev');
          } else {
            // Swipe para a esquerda - pr√≥ximo modelo
            switchModel(chartType, 'next');
          }
        }
        
        isSwiping = false;
      });
      
      // Suporte a clique nos pontos do indicador
      const dots = container.querySelectorAll('.model-dot');
      dots.forEach((dot, index) => {
        dot.addEventListener('click', function() {
          if (index !== state.activeModels[chartType]) {
            state.activeModels[chartType] = index;
            updateModelIndicators(chartType);
            updateChartWithModelData(chartType);
          }
        });
      });
    });
  }

  // Carregar previs√£o principal (condi√ß√µes atuais)
  function loadForecast() {
    try {
      const now = Date.now();
      if (now - state.lastUpdate < 15000) return;
      state.lastUpdate = now;
      
      const url = new URL('https://api.open-meteo.com/v1/forecast');
      url.search = new URLSearchParams({
        latitude: state.pos.lat,
        longitude: state.pos.lon,
        hourly: 'temperature_2m,relativehumidity_2m,precipitation,precipitation_probability,rain,showers,weathercode,apparent_temperature,uv_index',
        daily: 'temperature_2m_max,temperature_2m_min,precipitation_sum,precipitation_probability_max,weathercode,apparent_temperature_max,apparent_temperature_min,uv_index_max',
        timezone: 'America/Sao_Paulo',
        forecast_days: 16
      }).toString();

      fetch(url)
        .then(function(res) {
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return res.json();
        })
        .then(function(data) {
          const H = data.hourly;
          const D = data.daily;
          
          // Encontrar √≠ndice do hor√°rio atual
          let idx = 0;
          for (let i = 0; i < H.time.length; i++) {
            if (new Date(H.time[i]) >= new Date()) {
              idx = i;
              break;
            }
          }
          
          const end = Math.min(H.time.length, idx + 360);
          
          // Atualizar condi√ß√µes atuais
          const temp = Math.round((H.temperature_2m && H.temperature_2m[idx] != null) ? H.temperature_2m[idx] : 0);
          const hum = Math.round((H.relativehumidity_2m && H.relativehumidity_2m[idx] != null) ? H.relativehumidity_2m[idx] : 0);
          const code = (H.weathercode && H.weathercode[idx] != null) ? H.weathercode[idx] : 0;
          const prob = (H.precipitation_probability && H.precipitation_probability[idx] != null) ? H.precipitation_probability[idx] : 0;
          const rainHr = ((H.rain && H.rain[idx] != null) ? H.rain[idx] : 0) + 
                         ((H.showers && H.showers[idx] != null) ? H.showers[idx] : 0);
          const sumToday = (D.precipitation_sum && D.precipitation_sum[0] != null) ? D.precipitation_sum[0] : null;

          $('currentTemp').textContent = temp + "¬∞C";
          $('humidityValue').textContent = hum + "%";
          $('humidityBar').style.width = hum + "%";
          $('currentCondition').textContent = getDesc(code);
          $('weatherIcon').textContent = getIcon(code);
          updateBackground(code);
          $('kProb').textContent = prob + "%";
          $('kRain').textContent = rainHr.toFixed(1) + " mm";
          $('kSum').textContent = (sumToday != null ? sumToday.toFixed(1) : '--') + " mm";

          // Calcular alerta para as pr√≥ximas 3 horas
          let maxProb = 0, sumRain = 0;
          for (let i = idx; i < Math.min(idx + 3, H.time.length); i++) {
            const p = (H.precipitation_probability && H.precipitation_probability[i] != null) ? H.precipitation_probability[i] : 0;
            const r = ((H.rain && H.rain[i] != null) ? H.rain[i] : 0) + 
                      ((H.showers && H.showers[i] != null) ? H.showers[i] : 0);
            if (p > maxProb) maxProb = p;
            sumRain += r;
          }
          
          let cls = 'ok';
          let txt = 'Sem sinal relevante de chuva nas pr√≥ximas horas.';
          
          if (maxProb >= 80 && sumRain >= 10) {
            cls = 'bad';
            txt = 'Chuva forte prov√°vel (3h): prob. ' + maxProb + '%, ~' + sumRain.toFixed(1) + ' mm.';
          } else if (maxProb >= 60 && sumRain >= 3) {
            cls = 'warn';
            txt = 'Chuva moderada poss√≠vel (3h): prob. ' + maxProb + '%, ~' + sumRain.toFixed(1) + ' mm.';
          } else if (maxProb >= 30) {
            cls = 'ok';
            txt = 'Possibilidade de chuva fraca (prob. ' + maxProb + '%).';
          }
          
          const aEl = $('alertMsg');
          if (!aEl.classList.contains(cls) || aEl.textContent !== txt) {
            aEl.className = 'alert ' + cls;
            aEl.textContent = txt;
          }

          // Encontrar pico de probabilidade de chuva nos pr√≥ximos 15 dias
          let peakIdx = 0;
          let peakP = (D.precipitation_probability_max && D.precipitation_probability_max[0] != null) ? D.precipitation_probability_max[0] : 0;
          
          for (let j = 1; j < Math.min(15, D.time.length); j++) {
            const pj = (D.precipitation_probability_max && D.precipitation_probability_max[j] != null) ? D.precipitation_probability_max[j] : 0;
            if (pj > peakP) {
              peakP = pj;
              peakIdx = j;
            }
          }
          
          const pDate = new Date(D.time[peakIdx]);
          $('peakTime').textContent = pDate.toLocaleDateString('pt-BR', {
            weekday: 'long',
            day: 'numeric',
            month: 'long'
          });
          $('peakProb').textContent = 'Probabilidade: ' + peakP + '%';

          // Processar dados para gr√°ficos
          processChartData('openmeteo', 'rain', data);
          processChartData('openmeteo', 'temp', data);
          processChartData('openmeteo', 'feel', data);
          processChartData('openmeteo', 'uv', data);

          // Encontrar extremos de temperatura
          let cold = { t: +Infinity, time: null };
          let hot = { t: -Infinity, time: null };
          
          for (let hh = idx; hh < end; hh++) {
            const th = (H.temperature_2m && H.temperature_2m[hh] != null) ? H.temperature_2m[hh] : null;
            if (th == null) continue;
            
            if (th < cold.t) {
              cold.t = th;
              cold.time = H.time[hh];
            }
            
            if (th > hot.t) {
              hot.t = th;
              hot.time = H.time[hh];
            }
          }
          
          // Encontrar temperatura m√≠nima na previs√£o
          let minTemp = { t: +Infinity, time: null };
          for (let td = 0; td < 15 && td < D.time.length; td++) {
            const tMinVal = (D.temperature_2m_min && D.temperature_2m_min[td] != null) ? D.temperature_2m_min[td] : null;
            if (tMinVal !== null && tMinVal < minTemp.t) {
              minTemp.t = tMinVal;
              minTemp.time = D.time[td];
            }
          }
          
          let coldStr = '--';
          let hotStr = '--';
          let minTempStr = '--';
          
          if (cold.time) {
            const cd = new Date(cold.time);
            coldStr = cd.toLocaleDateString('pt-BR', {
              weekday: 'long',
              day: '2-digit',
              month: 'long'
            }) + ' √†s ' + cd.toLocaleTimeString('pt-BR', {
              hour: '2-digit',
              minute: '2-digit'
            }) + ' ‚Ä¢ ' + cold.t.toFixed(1) + '¬∞C';
          }
          
          if (hot.time) {
            const hd = new Date(hot.time);
            hotStr = hd.toLocaleDateString('pt-BR', {
              weekday: 'long',
              day: '2-digit',
              month: 'long'
            }) + ' √†s ' + hd.toLocaleTimeString('pt-BR', {
              hour: '2-digit',
              minute: '2-digit'
            }) + ' ‚Ä¢ ' + hot.t.toFixed(1) + '¬∞C';
          }
          
          if (minTemp.time) {
            const md = new Date(minTemp.time);
            minTempStr = md.toLocaleDateString('pt-BR', {
              weekday: 'long',
              day: '2-digit',
              month: 'long'
            }) + ' ‚Ä¢ ' + minTemp.t.toFixed(1) + '¬∞C';
          }
          
          $('extremesTemp').textContent = 'Mais frio: ' + coldStr + ' ‚Ä¢ Mais quente: ' + hotStr;
          $('extremesMin').textContent = 'M√≠nima mais baixa: ' + minTempStr;

        })
        .catch(function(e) {
          const aEl = $('alertMsg');
          aEl.className = 'alert warn';
          aEl.textContent = 'Erro ao carregar previs√£o. Nova tentativa em 30s.';
          console.warn('[forecast]', e);
        });
    } catch(e) {
      const aEl = $('alertMsg');
      aEl.className = 'alert warn';
      aEl.textContent = 'Erro ao carregar previs√£o. Nova tentativa em 30s.';
      console.warn('[forecast]', e);
    }
  }

  function setPos(lat, lon) {
    state.pos = { lat: lat, lon: lon };
    resolveAddress(lat, lon);
    loadForecast();
    
    // Carregar dados para todos os modelos
    MODELS.forEach(model => {
      ['rain', 'temp', 'feel', 'uv'].forEach(chartType => {
        loadModelData(model.id, chartType);
      });
    });
  }

  function startGPS() {
    if (!navigator.geolocation) {
      gpsStatus.textContent = 'Sem geolocaliza√ß√£o';
      gpsDot.className = 'gps-dot error';
      setPos(-22.86, -43.28);
      return;
    }
    
    gpsStatus.textContent = 'Buscando‚Ä¶';
    gpsDot.className = 'gps-dot searching';
    
    navigator.geolocation.getCurrentPosition(
      function(pos) {
        const c = pos.coords;
        gpsStatus.textContent = 'Localiza√ß√£o ativa';
        gpsDot.className = 'gps-dot';
        setPos(c.latitude, c.longitude);
      },
      function() {
        gpsStatus.textContent = 'Padr√£o: Zona Norte RJ';
        gpsDot.className = 'gps-dot searching';
        setPos(-22.86, -43.28);
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
    );
    
    // Observar mudan√ßas de posi√ß√£o (atualizar apenas se movimento > 250m)
    const R = 6371000; // Raio da Terra em metros
    let base = null;
    
    function dist(a, b) {
      const d2r = Math.PI / 180;
      const dLat = (b.lat - a.lat) * d2r;
      const dLon = (b.lon - a.lon) * d2r;
      const la = a.lat * d2r;
      const lb = b.lat * d2r;
      
      const s = Math.pow(Math.sin(dLat / 2), 2) + 
                Math.cos(la) * Math.cos(lb) * Math.pow(Math.sin(dLon / 2), 2);
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    
    state.watchId = navigator.geolocation.watchPosition(
      function(p) {
        const n = { lat: p.coords.latitude, lon: p.coords.longitude };
        if (!base) base = n;
        
        if (dist(base, n) > 250) {
          base = n;
          setPos(n.lat, n.lon);
        }
      },
      function() {
        // Erro GPS - continuar usando √∫ltima posi√ß√£o conhecida
      },
      { enableHighAccuracy: true, maximumAge: 15000, timeout: 15000 }
    );
  }

  $('btnZN').addEventListener('click', function() {
    setPos(-22.86, -43.28);
  });

  // Inicializar a aplica√ß√£o
  startGPS();
  setInterval(loadForecast, 30000);
  
  // Configurar gestos de deslizar ap√≥s o DOM estar completamente carregado
  setTimeout(setupSwipeGestures, 100);

  // Auto-testes
  (function() {
    try {
      console.assert(typeof Chart === 'function', 'Chart.js carregado');
      ['chartRain', 'chartTemp', 'chartFeel', 'chartUV'].forEach(function(id) {
        console.assert($(id), id + ' existe no DOM');
      });
      console.log('[Self-tests] OK');
    } catch(e) {
      console.warn('[Self-tests] falhou', e);
    }
  })();
});
</script>
</body>
</html>
